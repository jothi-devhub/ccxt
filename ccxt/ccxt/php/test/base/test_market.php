<?php
namespace ccxt;
use \ccxt\Precise;

// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// -----------------------------------------------------------------------------
include_once __DIR__ . '/test_shared_methods.php';

function test_market($exchange, $method, $market) {
    $format = array(
        'id' => 'btcusd',
        'symbol' => 'BTC/USD',
        'base' => 'BTC',
        'quote' => 'USD',
        'taker' => $exchange->parse_number('0.0011'),
        'maker' => $exchange->parse_number('0.0009'),
        'baseId' => 'btc',
        'quoteId' => 'usd',
        'active' => true,
        'type' => 'spot',
        'linear' => false,
        'inverse' => false,
        'spot' => true,
        'swap' => false,
        'future' => false,
        'option' => false,
        'margin' => false,
        'contract' => false,
        'contractSize' => $exchange->parse_number('0.001'),
        'expiry' => 1656057600000,
        'expiryDatetime' => '2022-06-24T08:00:00.000Z',
        'optionType' => 'put',
        'strike' => $exchange->parse_number('56000'),
        'settle' => 'XYZ',
        'settleId' => 'Xyz',
        'precision' => array(
            'price' => $exchange->parse_number('8'),
            'amount' => $exchange->parse_number('8'),
            'cost' => $exchange->parse_number('8'),
        ),
        'limits' => array(
            'amount' => array(
                'min' => $exchange->parse_number('0.01'),
                'max' => $exchange->parse_number('1000'),
            ),
            'price' => array(
                'min' => $exchange->parse_number('0.01'),
                'max' => $exchange->parse_number('1000'),
            ),
            'cost' => array(
                'min' => $exchange->parse_number('0.01'),
                'max' => $exchange->parse_number('1000'),
            ),
        ),
        'info' => array(),
    );
    $empty_not_allowed_for = ['id', 'symbol', 'base', 'quote', 'baseId', 'quoteId', 'precision', 'limits', 'type', 'spot', 'swap', 'future', 'contract'];
    assert_structure($exchange, $method, $market, $format, $empty_not_allowed_for);
    assert_symbol($exchange, $method, $market, 'symbol');
    $log_text = log_template($exchange, $method, $market);
    //
    assert_greater($exchange, $method, $market, 'contractSize', '0');
    assert_greater($exchange, $method, $market, 'expiry', '0');
    assert_greater($exchange, $method, $market, 'strike', '0');
    assert_in_array($exchange, $method, $market, 'optionType', ['put', 'call']);
    assert_greater($exchange, $method, $market, 'taker', '-100');
    assert_greater($exchange, $method, $market, 'maker', '-100');
    if ($market['contract']) {
        assert($market['linear'] !== $market['inverse'], 'market linear and inverse must not be the same' . $log_text);
    } else {
        assert(($market['linear'] === null) && ($market['inverse'] === null), 'market linear and inverse must be undefined when \"contract\" is false' . $log_text);
    }
    if ($market['option']) {
        assert($market['strike'] !== null, '\"strike\" must be defined when \"option\" is true' . $log_text);
        assert($market['optionType'] !== null, '\"optionType\" must be defined when \"option\" is true' . $log_text);
    }
    $valid_types = ['spot', 'margin', 'swap', 'future', 'option'];
    assert_in_array($exchange, $method, $market, 'type', $valid_types);
    $types = $valid_types;
    for ($i = 0; $i < count($types); $i++) {
        assert_in_array($exchange, $method, $market, $types[$i], [true, false, null]);
    }
    if ($market['future']) {
        assert(!$market['swap'] && !$market['option'], 'market swap and option must be false when \"future\" is true' . $log_text);
    } elseif ($market['swap']) {
        assert(!$market['future'] && !$market['option'], 'market future and option must be false when \"swap\" is true' . $log_text);
    } elseif ($market['option']) {
        assert(!$market['future'] && !$market['swap'], 'market future and swap must be false when \"option\" is true' . $log_text);
    }
    if ($market['linear']) {
        assert(!$market['inverse'], 'market inverse must be false when \"linear\" is true' . $log_text);
    } elseif ($market['inverse']) {
        assert(!$market['linear'], 'market linear must be false when \"inverse\" is true' . $log_text);
    }
    if ($market['future']) {
        assert($market['expiry'] !== null, '\"expiry\" must be defined when \"future\" is true' . $log_text);
        assert($market['expiryDatetime'] !== null, '\"expiryDatetime\" must be defined when \"future\" is true' . $log_text);
    }
    if ($market['expiry'] !== null) {
        assert($market['expiryDatetime'] === $exchange->iso8601($market['expiry']), 'expiryDatetime must be equal to expiry in iso8601 format' . $log_text);
    }
    $target_keys = ['cost', 'amount', 'price'];
    // check precisions
    for ($i = 0; $i < count($target_keys); $i++) {
        $key = $target_keys[$i];
        // todo: should be migrated into assertGreater after TickSize handling is implemented
        assert_greater_or_equal($exchange, $method, $market['precision'], $key, '0');
    }
    // check limits
    for ($i = 0; $i < count($target_keys); $i++) {
        $key = $target_keys[$i];
        $limit_entry = $market['limits'][$key];
        assert_greater_or_equal($exchange, $method, $limit_entry, 'min', '0');
        assert_greater($exchange, $method, $limit_entry, 'max', '0');
    }
}
