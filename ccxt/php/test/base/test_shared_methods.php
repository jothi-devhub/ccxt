<?php
namespace ccxt;
use \ccxt\Precise;

// ----------------------------------------------------------------------------

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

// -----------------------------------------------------------------------------


function log_template($exchange, $method, $entry) {
    return ' <<< ' . $exchange->id . ' ' . $method . ' ::: ' . $exchange->json($entry) . ' >>> ';
}


function assert_type($exchange, $entry, $key, $format) {
    // because "typeof" string is not transpilable without === 'name', we list them manually at this moment
    $entry_key_val = $exchange->safe_value($entry, $key);
    $format_key_val = $exchange->safe_value($format, $key);
    $same_string = (is_string($entry_key_val)) && (is_string($format_key_val));
    $same_numeric = ((is_int($entry_key_val) || is_float($entry_key_val))) && ((is_int($format_key_val) || is_float($format_key_val)));
    // todo: the below is correct, but is not being transpiled into python correctly: (x == False) instead of (x is False)
    // const same_boolean = ((entryKeyVal === true) || (entryKeyVal === false)) && ((formatKeyVal === true) || (formatKeyVal === false));
    $same_boolean = (($entry_key_val || !$entry_key_val) && ($format_key_val || !$format_key_val));
    $same_array = gettype($entry_key_val) === 'array' && array_keys($entry_key_val) === array_keys(array_keys($entry_key_val)) && gettype($format_key_val) === 'array' && array_keys($format_key_val) === array_keys(array_keys($format_key_val));
    $same_object = (is_array($entry_key_val)) && (is_array($format_key_val));
    $result = ($entry_key_val === null) || $same_string || $same_numeric || $same_boolean || $same_array || $same_object;
    return $result;
}


function assert_structure($exchange, $method, $entry, $format, $empty_not_allowed_for = []) {
    $log_text = log_template($exchange, $method, $entry);
    assert($entry, 'item is null/undefined' . $log_text);
    // get all expected & predefined keys for this specific item and ensure thos ekeys exist in parsed structure
    if (gettype($format) === 'array' && array_keys($format) === array_keys(array_keys($format))) {
        assert(gettype($entry) === 'array' && array_keys($entry) === array_keys(array_keys($entry)), 'entry is not an array' . $log_text);
        $real_length = count($entry);
        $expected_length = count($format);
        assert($real_length === $expected_length, 'entry length is not equal to expected length of ' . ((string) $expected_length) . $log_text);
        for ($i = 0; $i < count($format); $i++) {
            $is_in_array = $exchange->in_array($i, $empty_not_allowed_for);
            if ($is_in_array) {
                assert(($entry[$i] !== null), ((string) $i) . ' index is undefined, but is is was expected to be set' . $log_text);
            }
            // because of other langs, this is needed for arrays
            assert(assert_type($exchange, $entry, $i, $format), ((string) $i) . ' index does not have an expected type ' . $log_text);
        }
    } else {
        assert(is_array($entry), 'entry is not an object' . $log_text);
        $keys = is_array($format) ? array_keys($format) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            $key_str = ((string) $key);
            assert((is_array($entry) && array_key_exists($key, $entry)), $key_str . ' key is missing from structure' . $log_text);
            if ($exchange->in_array($key, $empty_not_allowed_for)) {
                // if it was in needed keys, then it should have value.
                assert($entry[$key] !== null, $key . ' key has an null value, but is expected to have a value' . $log_text);
            }
            assert(assert_type($exchange, $entry, $key, $format), $key . ' key is neither undefined, neither of expected type' . $log_text);
        }
    }
}


function assert_timestamp($exchange, $method, $entry, $now_to_check = null, $key_name = 'timestamp') {
    $log_text = log_template($exchange, $method, $entry);
    $is_date_time_object = is_string($key_name);
    if ($is_date_time_object) {
        assert((is_array($entry) && array_key_exists($key_name, $entry)), 'timestamp key ' . $key_name . ' is missing from structure' . $log_text);
    } else {
        // if index was provided (mostly from fetchOHLCV) then we check if it exists, as mandatory
        assert(!($entry[$key_name] === null), 'timestamp index ' . ((string) $key_name) . ' is undefined' . $log_text);
    }
    $ts = $entry[$key_name];
    if ($ts !== null) {
        // todo: add transpilable is_integer
        assert((is_int($ts) || is_float($ts)), 'timestamp is not numeric' . $log_text);
        assert($ts > 1230940800000, 'timestamp is impossible to be before 1230940800000 / 03.01.2009' . $log_text); // 03 Jan 2009 - first block
        assert($ts < 2147483648000, 'timestamp more than 2147483648000 / 19.01.2038' . $log_text); // 19 Jan 2038 - int32 overflows // 7258118400000  -> Jan 1 2200
        if ($now_to_check !== null) {
            assert($ts < $now_to_check + 60000, 'trade timestamp is not below current time. Returned datetime: ' . $exchange->iso8601($ts) . ', now: ' . $exchange->iso8601($now_to_check) . $log_text);
        }
    }
    // only in case if the entry is a dictionary, thus it must have 'timestamp' & 'datetime' string keys
    if ($is_date_time_object) {
        // we also test 'datetime' here because it's certain sibling of 'timestamp'
        assert((is_array($entry) && array_key_exists('datetime', $entry)), 'datetime is missing from structure' . $log_text);
        $dt = $entry['datetime'];
        if ($dt !== null) {
            assert(is_string($dt), 'datetime is not a string' . $log_text);
            assert($dt === $exchange->iso8601($entry['timestamp']), 'datetime is not iso8601 of timestamp' . $log_text);
        }
    }
}


function assert_currency_code($exchange, $method, $entry, $actual_code, $expected_code = null) {
    $log_text = log_template($exchange, $method, $entry);
    if ($actual_code !== null) {
        assert(is_string($actual_code), 'currency code should be either undefined or a string' . $log_text);
        assert((is_array($exchange->currencies) && array_key_exists($actual_code, $exchange->currencies)), 'currency code should be present in exchange.currencies' . $log_text);
        if ($expected_code !== null) {
            assert($actual_code === $expected_code, 'currency code in response (' . $actual_code . ') should be equal to expected code (' . $expected_code . ')' . $log_text);
        }
    }
}


function assert_symbol($exchange, $method, $entry, $key, $expected_symbol = null) {
    $log_text = log_template($exchange, $method, $entry);
    $actual_symbol = $exchange->safe_string($entry, $key);
    if ($actual_symbol !== null) {
        assert(is_string($actual_symbol), 'symbol should be either undefined or a string' . $log_text);
        assert((is_array($exchange->markets) && array_key_exists($actual_symbol, $exchange->markets)), 'symbol should be present in exchange.symbols' . $log_text);
    }
    if ($expected_symbol !== null) {
        assert($actual_symbol === $expected_symbol, 'symbol in response (' . $actual_symbol . ') should be equal to expected symbol (' . $expected_symbol . ')' . $log_text);
    }
}


function assert_greater($exchange, $method, $entry, $key, $compare_to) {
    $log_text = log_template($exchange, $method, $entry);
    $value = $exchange->safe_string($entry, $key);
    if ($value !== null) {
        $key_str = null;
        if (is_string($key)) {
            $key_str = $key;
        } else {
            $key_str = ((string) $key);
        }
        $compare_to_str = null;
        if (is_string($compare_to)) {
            $compare_to_str = $compare_to;
        } else {
            $compare_to_str = ((string) $compare_to);
        }
        assert(Precise::string_gt($value, $compare_to), $key_str . ' key (with a value of ' . $value . ') was expected to be > ' . $compare_to_str . $log_text);
    }
}


function assert_greater_or_equal($exchange, $method, $entry, $key, $compare_to) {
    $log_text = log_template($exchange, $method, $entry);
    $value = $exchange->safe_string($entry, $key);
    if ($value !== null) {
        $key_str = null;
        if (is_string($key)) {
            $key_str = $key;
        } else {
            $key_str = ((string) $key);
        }
        $compare_to_str = null;
        if (is_string($compare_to)) {
            $compare_to_str = $compare_to;
        } else {
            $compare_to_str = ((string) $compare_to);
        }
        assert(Precise::string_ge($value, $compare_to), $key_str . ' key (with a value of ' . $value . ') was expected to be >= ' . $compare_to_str . $log_text);
    }
}


function assert_less($exchange, $method, $entry, $key, $compare_to) {
    $log_text = log_template($exchange, $method, $entry);
    $value = $exchange->safe_string($entry, $key);
    if ($value !== null) {
        $key_str = null;
        if (is_string($key)) {
            $key_str = $key;
        } else {
            $key_str = ((string) $key);
        }
        $compare_to_str = null;
        if (is_string($compare_to)) {
            $compare_to_str = $compare_to;
        } else {
            $compare_to_str = ((string) $compare_to);
        }
        assert(Precise::string_lt($value, $compare_to), $key_str . ' key (with a value of ' . $value . ') was expected to be < ' . $compare_to_str . $log_text);
    }
}


function assert_less_or_equal($exchange, $method, $entry, $key, $compare_to) {
    $log_text = log_template($exchange, $method, $entry);
    $value = $exchange->safe_string($entry, $key);
    if ($value !== null) {
        $key_str = null;
        if (is_string($key)) {
            $key_str = $key;
        } else {
            $key_str = ((string) $key);
        }
        $compare_to_str = null;
        if (is_string($compare_to)) {
            $compare_to_str = $compare_to;
        } else {
            $compare_to_str = ((string) $compare_to);
        }
        assert(Precise::string_le($value, $compare_to), $key_str . ' key (with a value of ' . $value . ') was expected to be <= ' . $compare_to_str . $log_text);
    }
}


function assert_in_array($exchange, $method, $entry, $key, $expected_array) {
    $log_text = log_template($exchange, $method, $entry);
    $value = $exchange->safe_value($entry, $key);
    if ($value !== null) {
        $key_str = null;
        if (is_string($key)) {
            $key_str = $key;
        } else {
            $key_str = ((string) $key);
        }
        assert($exchange->in_array($value, $expected_array), $key_str . ' key (with a value of ' . $value . ') was expected to be one from: [' . implode(',', $expected_array) . ']' . $log_text);
    }
}


function assert_fee($exchange, $method, $entry) {
    $log_text = log_template($exchange, $method, $entry);
    if ($entry !== null) {
        assert((is_array($entry) && array_key_exists('cost', $entry)), '\"fee\" should contain a \"cost\" key' . $log_text);
        assert_greater_or_equal($exchange, $method, $entry, 'cost', '0');
        assert((is_array($entry) && array_key_exists('currency', $entry)), '\"fee\" should contain a \"currency\" key' . $log_text);
        assert_currency_code($exchange, $method, $entry, $entry['currency']);
    }
}


function assert_fees($exchange, $method, $entry) {
    $log_text = log_template($exchange, $method, $entry);
    if ($entry !== null) {
        assert(gettype($entry) === 'array' && array_keys($entry) === array_keys(array_keys($entry)), '\"fees\" is not an array' . $log_text);
        for ($i = 0; $i < count($entry); $i++) {
            assert_fee($exchange, $method, $entry[$i]);
        }
    }
}


function assert_timestamp_order($exchange, $method, $code_or_symbol, $items, $ascending = false) {
    for ($i = 0; $i < count($items); $i++) {
        if ($i > 0) {
            $ascending_or_descending = $ascending ? 'ascending' : 'descending';
            $first_index = $ascending ? $i - 1 : $i;
            $second_index = $ascending ? $i : $i - 1;
            assert($items[$first_index]['timestamp'] >= $items[$second_index]['timestamp'], $exchange->id . ' ' . $method . ' ' . $code_or_symbol . ' must return a ' . $ascending_or_descending . ' sorted array of items by timestamp. ' . $exchange->json($items));
        }
    }
}
